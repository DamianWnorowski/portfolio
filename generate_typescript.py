#!/usr/bin/env python3
"""
AGENT 2: Generate TypeScript definitions with JSDoc for all commands
"""
import json
from pathlib import Path
from typing import Dict, List, Any

def generate_typescript_defs(commands_data: Dict[str, Any]) -> str:
    """Generate TypeScript .d.ts file with comprehensive JSDoc"""
    lines = []
    lines.append("/**")
    lines.append(" * Claude Automation Core - Command Type Definitions")
    lines.append(f" * Total Commands: {len(commands_data['commands'])}")
    lines.append(" * Auto-generated by AGENT 2")
    lines.append(" */\n")

    # Command parameter interface
    lines.append("/** Command parameter definition */")
    lines.append("export interface CommandParameter {")
    lines.append("  name: string;")
    lines.append("  type: 'string' | 'number' | 'boolean' | 'array' | 'object';")
    lines.append("  description?: string;")
    lines.append("  required?: boolean;")
    lines.append("  default?: any;")
    lines.append("}\n")

    # Command result interface
    lines.append("/** Command execution result */")
    lines.append("export interface CommandResult {")
    lines.append("  success: boolean;")
    lines.append("  output?: string;")
    lines.append("  error?: string;")
    lines.append("  data?: any;")
    lines.append("}\n")

    # Command metadata interface
    lines.append("/** Command metadata */")
    lines.append("export interface CommandMetadata {")
    lines.append("  name: string;")
    lines.append("  filename: string;")
    lines.append("  purpose: string;")
    lines.append("  categories: string[];")
    lines.append("  parameters: CommandParameter[];")
    lines.append("  dependencies: string[];")
    lines.append("}\n")

    # Category enum
    categories = sorted(commands_data['taxonomy'].keys())
    lines.append("/** Command categories */")
    lines.append("export enum CommandCategory {")
    for cat in categories:
        lines.append(f"  {cat.title()} = '{cat}',")
    lines.append("}\n")

    # Command names type
    lines.append("/** All available command names */")
    lines.append("export type CommandName =")
    for i, cmd in enumerate(sorted(commands_data['commands'], key=lambda x: x['name'])):
        separator = " |" if i < len(commands_data['commands']) - 1 else ";"
        lines.append(f"  | '{cmd['name']}'{separator}")
    lines.append("")

    # Individual command interfaces
    lines.append("/** Individual command interfaces with specific parameters */\n")
    for cmd in sorted(commands_data['commands'], key=lambda x: x['name']):
        # JSDoc comment
        lines.append("/**")
        lines.append(f" * {cmd['name']}")
        if cmd['purpose']:
            first_line = cmd['purpose'].split('\n')[0].strip('- ').strip()
            lines.append(f" * {first_line}")
        lines.append(f" * @category {', '.join(cmd['categories'])}")
        if cmd['dependencies']:
            lines.append(f" * @requires {', '.join(cmd['dependencies'])}")

        # Add usage example
        if cmd['usage']:
            usage_lines = cmd['usage'].split('\n')[:3]  # First 3 lines
            lines.append(" * @example")
            for usage_line in usage_lines:
                if usage_line.strip():
                    lines.append(f" * {usage_line.strip()}")
        lines.append(" */")

        # Interface name from command name
        interface_name = cmd['filename'].replace('-', '_').title().replace('_', '') + "Command"

        lines.append(f"export interface {interface_name} {{")
        lines.append(f"  command: '{cmd['name']}';")

        if cmd['parameters']:
            lines.append("  parameters?: {")
            for param in cmd['parameters']:
                param_type = {
                    'string': 'string',
                    'number': 'number',
                    'boolean': 'boolean',
                    'array': 'any[]',
                    'object': 'Record<string, any>'
                }.get(param['type'], 'string')

                param_doc = f"    /** {param['description']} */" if param['description'] else ""
                if param_doc:
                    lines.append(param_doc)
                lines.append(f"    {param['name']}?: {param_type};")
            lines.append("  };")

        lines.append("}\n")

    # Command executor interface
    lines.append("/** Command executor function signature */")
    lines.append("export interface CommandExecutor {")
    lines.append("  (command: CommandName, parameters?: Record<string, any>): Promise<CommandResult>;")
    lines.append("}\n")

    # Command registry
    lines.append("/** Command registry mapping */")
    lines.append("export interface CommandRegistry {")
    for cmd in sorted(commands_data['commands'], key=lambda x: x['name']):
        lines.append(f"  '{cmd['name']}': CommandMetadata;")
    lines.append("}\n")

    # Statistics
    lines.append("/** Command statistics */")
    lines.append("export interface CommandStats {")
    lines.append(f"  totalCommands: {commands_data['stats']['total_commands']};")
    lines.append(f"  totalCategories: {commands_data['stats']['total_categories']};")
    lines.append(f"  commandsWithDependencies: {commands_data['stats']['commands_with_dependencies']};")
    lines.append(f"  commandsWithParameters: {commands_data['stats']['commands_with_parameters']};")
    lines.append("}\n")

    return '\n'.join(lines)

def generate_usage_examples(commands_data: Dict[str, Any]) -> str:
    """Generate TypeScript usage examples"""
    lines = []
    lines.append("/**")
    lines.append(" * Claude Automation Core - Usage Examples")
    lines.append(" * Demonstrates how to use the command type definitions")
    lines.append(" */\n")

    lines.append('import type {')
    lines.append('  CommandExecutor,')
    lines.append('  CommandResult,')
    lines.append('  CommandName,')
    lines.append('  CommandMetadata,')
    lines.append('} from "./commands.d.ts";\n')

    lines.append("// Example 1: Basic command execution")
    lines.append("async function executeCommand(")
    lines.append("  executor: CommandExecutor,")
    lines.append("  command: CommandName")
    lines.append("): Promise<CommandResult> {")
    lines.append("  return await executor(command);")
    lines.append("}\n")

    lines.append("// Example 2: Command with parameters")
    lines.append("async function analyzeCustomFiles(executor: CommandExecutor) {")
    lines.append('  return await executor("/analyze-custom-files", {')
    lines.append('    "output-format": "json"')
    lines.append("  });")
    lines.append("}\n")

    lines.append("// Example 3: Chained commands")
    lines.append("async function evolutionCycle(executor: CommandExecutor) {")
    lines.append('  const analyze = await executor("/analyze-custom-files");')
    lines.append('  const status = await executor("/evolution-status");')
    lines.append('  const orchestrate = await executor("/multi-ai-orchestrate");')
    lines.append("  return { analyze, status, orchestrate };")
    lines.append("}\n")

    lines.append("// Example 4: Type-safe command dispatcher")
    lines.append("class CommandDispatcher {")
    lines.append("  constructor(private executor: CommandExecutor) {}\n")
    lines.append("  async dispatch(command: CommandName, params?: Record<string, any>) {")
    lines.append("    console.log(`Executing: ${command}`);")
    lines.append("    const result = await this.executor(command, params);")
    lines.append("    if (!result.success) {")
    lines.append("      throw new Error(`Command failed: ${result.error}`);")
    lines.append("    }")
    lines.append("    return result.data;")
    lines.append("  }")
    lines.append("}\n")

    return '\n'.join(lines)

def main():
    print("AGENT 2: Generating TypeScript definitions...")

    # Load parsed commands data from AGENT 1
    data_path = Path(r"C:\Users\Ouroboros\Desktop\portflio-agent1\docs\commands_data.json")

    # Wait for AGENT 1 to complete if needed
    if not data_path.exists():
        print("  [WAIT] Waiting for AGENT 1 to complete...")
        import time
        max_wait = 30
        waited = 0
        while not data_path.exists() and waited < max_wait:
            time.sleep(1)
            waited += 1

        if not data_path.exists():
            print("  [FAIL] AGENT 1 data not available")
            return

    commands_data = json.loads(data_path.read_text(encoding='utf-8'))
    print(f"  [OK] Loaded {len(commands_data['commands'])} commands")

    # Generate TypeScript definitions
    print("\nGenerating TypeScript definitions...")
    ts_defs = generate_typescript_defs(commands_data)

    output_dir = Path(r"C:\Users\Ouroboros\Desktop\portflio-agent2\types")
    output_dir.mkdir(parents=True, exist_ok=True)

    ts_path = output_dir / "commands.d.ts"
    ts_path.write_text(ts_defs, encoding='utf-8')
    print(f"  [OK] Written to {ts_path}")

    # Generate usage examples
    print("\nGenerating usage examples...")
    examples = generate_usage_examples(commands_data)
    examples_path = output_dir / "examples.ts"
    examples_path.write_text(examples, encoding='utf-8')
    print(f"  [OK] Written to {examples_path}")

    print("\n[COMPLETE] AGENT 2")
    print(f"  - TypeScript definitions: {ts_path}")
    print(f"  - Usage examples: {examples_path}")

if __name__ == '__main__':
    main()
